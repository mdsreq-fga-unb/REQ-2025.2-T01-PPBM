# Deploy to Kubernetes (In-Cluster Build with Real-time Logs)
# 
# This workflow uses in-cluster Kaniko builds with real-time log streaming.
# Frontend: ppbm.no-fluxo.com
# Backend API: api.ppbm.no-fluxo.com
# 
# Required Secrets:
#   - DEPLOY_API_KEY: Deploy API authentication key
#   - REPO_TOKEN: GitHub token with repo access
#   - SUPABASE_URL: Supabase project URL
#   - SUPABASE_SERVICE_ROLE_KEY: Supabase service role key
#   - SUPABASE_ANON_KEY: Supabase anon key for frontend

name: Deploy to Kubernetes

on:
  push:
    branches: [dev]
  workflow_dispatch:

env:
  DEPLOY_API_URL: https://deploy.kubernetes.crianex.com
  BACKEND_APP: ppbm-backend
  FRONTEND_APP: ppbm-frontend
  BACKEND_HOST: api.ppbm.no-fluxo.com
  FRONTEND_HOST: ppbm.no-fluxo.com
  NAMESPACE: apps

jobs:
  build-and-deploy-backend:
    runs-on: ubuntu-latest
    
    steps:
      - name: Trigger backend cluster build
        id: build
        run: |
          http_response=$(curl -s -w "\n%{http_code}" -X POST ${{ env.DEPLOY_API_URL }}/build \
            -H "Content-Type: application/json" \
            -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" \
            -d '{
              "app": "${{ env.BACKEND_APP }}",
              "namespace": "${{ env.NAMESPACE }}",
              "repoUrl": "https://github.com/${{ github.repository }}",
              "gitRef": "${{ github.sha }}",
              "gitToken": "${{ secrets.REPO_TOKEN }}",
              "dockerfile": "Dockerfile",
              "buildContext": ".",
              "imageTag": "${{ github.sha }}",
              "cache": true,
              "deploy": true,
              "deployConfig": {
                "port": 5919,
                "replicas": 1,
                "domain": "${{ env.BACKEND_HOST }}",
                "healthPath": "/health",
                "env": {
                  "NODE_ENV": "production",
                  "PORT": "5919",
                  "SUPABASE_URL": "${{ secrets.SUPABASE_URL }}",
                  "SUPABASE_SERVICE_ROLE_KEY": "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
                }
              },
              "resources": {
                "cpu": "1",
                "memory": "1Gi"
              }
            }')
          
          http_code=$(echo "$http_response" | tail -n1)
          response=$(echo "$http_response" | sed '$d')
          
          echo "HTTP Code: $http_code"
          echo "Response: $response"
          
          if [ "$http_code" -lt 200 ] || [ "$http_code" -ge 300 ]; then
            echo "âŒ API request failed with HTTP $http_code"
            echo "$response" | jq . 2>/dev/null || echo "$response"
            exit 1
          fi
          
          jobName=$(echo $response | jq -r '.jobName')
          image=$(echo $response | jq -r '.image')
          echo "job_name=$jobName" >> $GITHUB_OUTPUT
          echo "image=$image" >> $GITHUB_OUTPUT
          echo "ğŸš€ Backend build job started: $jobName"
          echo "ğŸ“¦ Image: $image"

      - name: Stream backend build logs
        run: |
          echo "ğŸ“‹ Streaming backend build logs..."
          echo "================================================"
          
          last_line_count=0
          timeout=900
          start_time=$(date +%s)
          
          while true; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ Build timed out after ${timeout}s"
              exit 1
            fi
            
            # Get current logs and print new lines
            logs=$(curl -sf "${{ env.DEPLOY_API_URL }}/build/${{ steps.build.outputs.job_name }}/logs" \
              -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null | jq -r '.logs // ""')
            
            if [ -n "$logs" ]; then
              current_line_count=$(echo "$logs" | wc -l)
              if [ "$current_line_count" -gt "$last_line_count" ]; then
                echo "$logs" | tail -n +$((last_line_count + 1))
                last_line_count=$current_line_count
              fi
            fi
            
            # Check build status
            status_response=$(curl -sf "${{ env.DEPLOY_API_URL }}/build/${{ steps.build.outputs.job_name }}" \
              -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null || echo '{"status":"pending"}')
            
            status=$(echo "$status_response" | jq -r '.status')
            
            if [ "$status" = "succeeded" ]; then
              # Print any remaining logs
              logs=$(curl -sf "${{ env.DEPLOY_API_URL }}/build/${{ steps.build.outputs.job_name }}/logs" \
                -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null | jq -r '.logs // ""')
              if [ -n "$logs" ]; then
                current_line_count=$(echo "$logs" | wc -l)
                if [ "$current_line_count" -gt "$last_line_count" ]; then
                  echo "$logs" | tail -n +$((last_line_count + 1))
                fi
              fi
              echo ""
              echo "================================================"
              echo "âœ… Backend build succeeded!"
              exit 0
            elif [ "$status" = "failed" ]; then
              echo ""
              echo "================================================"
              echo "âŒ Backend build failed!"
              exit 1
            fi
            
            sleep 3
          done

      - name: Wait for backend deployment to be ready
        run: |
          echo "â³ Waiting for backend deployment to be ready..."
          
          APP_NAME="${{ env.BACKEND_APP }}"
          NAMESPACE="${{ env.NAMESPACE }}"
          TIMEOUT=300
          POLL_INTERVAL=5
          
          start_time=$(date +%s)
          last_status=""
          
          while true; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            if [ $elapsed -ge $TIMEOUT ]; then
              echo ""
              echo "âŒ Deployment timed out after ${TIMEOUT}s"
              echo ""
              echo "ğŸ“Š Final deployment status:"
              curl -sf "${{ env.DEPLOY_API_URL }}/apps/${NAMESPACE}/${APP_NAME}" \
                -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" | jq .
              exit 1
            fi
            
            # Get deployment status
            response=$(curl -sf "${{ env.DEPLOY_API_URL }}/apps/${NAMESPACE}/${APP_NAME}" \
              -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null || echo '{"app":{"status":"unknown"}}')
            
            status=$(echo "$response" | jq -r '.app.status // "unknown"')
            ready=$(echo "$response" | jq -r '.app.readyReplicas // 0')
            desired=$(echo "$response" | jq -r '.app.replicas // 0')
            available=$(echo "$response" | jq -r '.app.availableReplicas // 0')
            
            # Print status update if changed
            current_status="${status}:${ready}/${desired}"
            if [ "$current_status" != "$last_status" ]; then
              echo "[${elapsed}s] Status: ${status} | Ready: ${ready}/${desired} | Available: ${available}"
              last_status="$current_status"
            fi
            
            # Check if deployment is ready
            if [ "$status" = "running" ]; then
              echo ""
              echo "================================================"
              echo "âœ… Backend deployment successful! ${ready}/${desired} replicas ready"
              echo "ğŸŒ URL: https://${{ env.BACKEND_HOST }}"
              echo "================================================"
              exit 0
            fi
            
            sleep $POLL_INTERVAL
          done

  build-and-deploy-frontend:
    runs-on: ubuntu-latest
    needs: build-and-deploy-backend
    
    steps:
      - name: Trigger frontend cluster build
        id: build
        run: |
          http_response=$(curl -s -w "\n%{http_code}" -X POST ${{ env.DEPLOY_API_URL }}/build \
            -H "Content-Type: application/json" \
            -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" \
            -d '{
              "app": "${{ env.FRONTEND_APP }}",
              "namespace": "${{ env.NAMESPACE }}",
              "repoUrl": "https://github.com/${{ github.repository }}",
              "gitRef": "${{ github.sha }}",
              "gitToken": "${{ secrets.REPO_TOKEN }}",
              "dockerfile": "Dockerfile.frontend",
              "buildContext": ".",
              "imageTag": "${{ github.sha }}",
              "buildArgs": {
                "PUBLIC_SUPABASE_URL": "${{ secrets.SUPABASE_URL }}",
                "PUBLIC_SUPABASE_ANON_KEY": "${{ secrets.SUPABASE_ANON_KEY }}",
                "PUBLIC_API_URL": "https://${{ env.BACKEND_HOST }}"
              },
              "cache": true,
              "deploy": true,
              "deployConfig": {
                "port": 4321,
                "replicas": 1,
                "domain": "${{ env.FRONTEND_HOST }}",
                "healthPath": "/",
                "env": {
                  "NODE_ENV": "production",
                  "PORT": "4321",
                  "HOST": "0.0.0.0",
                  "ORIGIN": "https://${{ env.FRONTEND_HOST }}"
                }
              },
              "resources": {
                "cpu": "1",
                "memory": "1Gi"
              }
            }')
          
          http_code=$(echo "$http_response" | tail -n1)
          response=$(echo "$http_response" | sed '$d')
          
          echo "HTTP Code: $http_code"
          echo "Response: $response"
          
          if [ "$http_code" -lt 200 ] || [ "$http_code" -ge 300 ]; then
            echo "âŒ API request failed with HTTP $http_code"
            echo "$response" | jq . 2>/dev/null || echo "$response"
            exit 1
          fi
          
          jobName=$(echo $response | jq -r '.jobName')
          image=$(echo $response | jq -r '.image')
          echo "job_name=$jobName" >> $GITHUB_OUTPUT
          echo "image=$image" >> $GITHUB_OUTPUT
          echo "ğŸš€ Frontend build job started: $jobName"
          echo "ğŸ“¦ Image: $image"

      - name: Stream frontend build logs
        run: |
          echo "ğŸ“‹ Streaming frontend build logs..."
          echo "================================================"
          
          last_line_count=0
          timeout=900
          start_time=$(date +%s)
          
          while true; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ Build timed out after ${timeout}s"
              exit 1
            fi
            
            # Get current logs and print new lines
            logs=$(curl -sf "${{ env.DEPLOY_API_URL }}/build/${{ steps.build.outputs.job_name }}/logs" \
              -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null | jq -r '.logs // ""')
            
            if [ -n "$logs" ]; then
              current_line_count=$(echo "$logs" | wc -l)
              if [ "$current_line_count" -gt "$last_line_count" ]; then
                echo "$logs" | tail -n +$((last_line_count + 1))
                last_line_count=$current_line_count
              fi
            fi
            
            # Check build status
            status_response=$(curl -sf "${{ env.DEPLOY_API_URL }}/build/${{ steps.build.outputs.job_name }}" \
              -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null || echo '{"status":"pending"}')
            
            status=$(echo "$status_response" | jq -r '.status')
            
            if [ "$status" = "succeeded" ]; then
              # Print any remaining logs
              logs=$(curl -sf "${{ env.DEPLOY_API_URL }}/build/${{ steps.build.outputs.job_name }}/logs" \
                -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null | jq -r '.logs // ""')
              if [ -n "$logs" ]; then
                current_line_count=$(echo "$logs" | wc -l)
                if [ "$current_line_count" -gt "$last_line_count" ]; then
                  echo "$logs" | tail -n +$((last_line_count + 1))
                fi
              fi
              echo ""
              echo "================================================"
              echo "âœ… Frontend build succeeded!"
              exit 0
            elif [ "$status" = "failed" ]; then
              echo ""
              echo "================================================"
              echo "âŒ Frontend build failed!"
              exit 1
            fi
            
            sleep 3
          done

      - name: Wait for frontend deployment to be ready
        run: |
          echo "â³ Waiting for frontend deployment to be ready..."
          
          APP_NAME="${{ env.FRONTEND_APP }}"
          NAMESPACE="${{ env.NAMESPACE }}"
          TIMEOUT=300
          POLL_INTERVAL=5
          
          start_time=$(date +%s)
          last_status=""
          
          while true; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            if [ $elapsed -ge $TIMEOUT ]; then
              echo ""
              echo "âŒ Deployment timed out after ${TIMEOUT}s"
              echo ""
              echo "ğŸ“Š Final deployment status:"
              curl -sf "${{ env.DEPLOY_API_URL }}/apps/${NAMESPACE}/${APP_NAME}" \
                -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" | jq .
              exit 1
            fi
            
            # Get deployment status
            response=$(curl -sf "${{ env.DEPLOY_API_URL }}/apps/${NAMESPACE}/${APP_NAME}" \
              -H "X-API-Key: ${{ secrets.DEPLOY_API_KEY }}" 2>/dev/null || echo '{"app":{"status":"unknown"}}')
            
            status=$(echo "$response" | jq -r '.app.status // "unknown"')
            ready=$(echo "$response" | jq -r '.app.readyReplicas // 0')
            desired=$(echo "$response" | jq -r '.app.replicas // 0')
            available=$(echo "$response" | jq -r '.app.availableReplicas // 0')
            
            # Print status update if changed
            current_status="${status}:${ready}/${desired}"
            if [ "$current_status" != "$last_status" ]; then
              echo "[${elapsed}s] Status: ${status} | Ready: ${ready}/${desired} | Available: ${available}"
              last_status="$current_status"
            fi
            
            # Check if deployment is ready
            if [ "$status" = "running" ]; then
              echo ""
              echo "================================================"
              echo "âœ… Frontend deployment successful! ${ready}/${desired} replicas ready"
              echo "ğŸŒ URL: https://${{ env.FRONTEND_HOST }}"
              echo "================================================"
              exit 0
            fi
            
            sleep $POLL_INTERVAL
          done

  summary:
    runs-on: ubuntu-latest
    needs: [build-and-deploy-backend, build-and-deploy-frontend]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "ğŸ‰ Deployment Summary"
          echo "===================="
          echo ""
          echo "ğŸ”— Frontend: https://${{ env.FRONTEND_HOST }}"
          echo "ğŸ”— Backend API: https://${{ env.BACKEND_HOST }}"
          echo "ğŸ”— Health Check: https://${{ env.BACKEND_HOST }}/health"
          echo ""
          echo "ğŸ“Š View logs in Grafana â†’ Explore â†’ Loki"
          echo "   Query: {app=\"${{ env.BACKEND_APP }}\"}"
